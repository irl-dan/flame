# Phase 1.3: Compaction Integration

**Status:** Next
**Prerequisites:** Phase 1.2 (Context Assembly) complete

---

## Goals

Phase 1.3 focuses on integrating with OpenCode's compaction system to generate meaningful frame summaries. From SYNTHESIS.md Section 5.2:

> **Phase 3: Compaction Integration**
> - Custom compaction prompts for frame completion
> - Compaction output capture via message events
> - Summary storage in frame metadata

The goal is to ensure that when a frame completes (via `flame_pop`), the LLM generates a summary that captures:
- What was accomplished
- Key decisions made
- Artifacts created or modified
- Any blockers or issues encountered

## Acceptance Criteria

- [ ] Frame completion triggers custom compaction with frame-aware prompt
- [ ] Compaction summary is captured from `session.compacted` event
- [ ] Summary is automatically stored in frame metadata (`compactionSummary` field)
- [ ] Completed frame context uses the generated summary (not raw messages)
- [ ] Overflow compaction (mid-frame) uses continuation prompt, not completion prompt
- [ ] Summary quality is sufficient for parent frame context

## What Needs to Be Built

### 1. Custom Compaction Prompts

Different prompts for different compaction scenarios:

**Frame Completion Prompt** (when `flame_pop` is called):
```typescript
const FRAME_COMPLETION_PROMPT = `
Summarize this frame's work for the parent context:
- Goal: {frame.goal}
- What was accomplished
- Key decisions made
- Artifacts created/modified
- Any issues or blockers

Keep the summary concise but complete enough that the parent frame
can understand what happened without accessing the full log.
`
```

**Overflow Continuation Prompt** (mid-frame compaction):
```typescript
const OVERFLOW_CONTINUATION_PROMPT = `
The context is being compacted due to length. Summarize the conversation
so far while preserving:
- Current progress toward goal: {frame.goal}
- Important context needed to continue
- Any pending decisions or blockers
`
```

### 2. Compaction Output Capture

Subscribe to `session.compacted` event to capture the generated summary:

```typescript
"event": async ({ event }) => {
  if (event.type === "session.compacted") {
    const sessionID = event.properties.sessionID
    const frame = frameState.getFrame(sessionID)
    if (frame && frame.status === "completing") {
      // Capture the compaction summary
      const summary = await extractSummaryFromSession(sessionID)
      await frameState.updateFrame(sessionID, {
        compactionSummary: summary,
        status: "completed"
      })
    }
  }
}
```

### 3. Summary Extraction

Extract the summary message from the compacted session:

```typescript
async function extractSummaryFromSession(sessionID: string): Promise<string> {
  // The compaction creates a message with summary: true
  // Need to read session messages and find the summary
  // This may require reading from session storage or using SDK
}
```

### 4. Frame Metadata Update

Update the FrameMetadata interface to properly handle summaries:

```typescript
interface FrameMetadata {
  // ... existing fields
  compactionSummary?: string      // Generated by compaction
  compactionTimestamp?: string    // When compaction occurred
}
```

## Proposed Approach

### Phase 1.3.1: Compaction Hook Enhancement

1. Detect frame status in `experimental.session.compacting` hook
2. Inject appropriate prompt based on status:
   - `completing` -> Frame completion prompt
   - `in_progress` -> Overflow continuation prompt
3. Include frame context in compaction prompt

### Phase 1.3.2: Summary Capture

1. Subscribe to `session.compacted` event
2. Read the summary message from session
3. Store in frame metadata
4. Update frame status to `completed`

### Phase 1.3.3: Context Integration

1. Update `generateFrameContext()` to use `compactionSummary` for completed frames
2. Fall back to goal + artifacts if no summary available
3. Test that parent frames see child summaries

## Test Plan

### 1. Frame Completion Tests

- Call `flame_pop completed` and verify:
  - Custom completion prompt is used
  - Summary is captured and stored
  - Frame status transitions to `completed`
  - Parent frame can see the summary

### 2. Overflow Compaction Tests

- Create a long conversation within a frame
- Trigger overflow compaction
- Verify continuation prompt is used (not completion)
- Verify frame remains `in_progress`

### 3. Summary Quality Tests

- Complete a frame with complex work
- Verify summary includes:
  - Goal reference
  - Accomplishments
  - Key decisions
  - Artifacts

### 4. Context Assembly Tests

- Complete a child frame
- Navigate to parent frame
- Verify child summary appears in context
- Verify raw messages are NOT included

## Dependencies

- Phase 1.2 Context Assembly (complete)
- `experimental.session.compacting` hook
- `session.compacted` event
- Flame plugin at `.opencode/plugin/flame.ts`

## References

- [SYNTHESIS.md](../design/SYNTHESIS.md) - Section 5.2 Phase 3
- [SPEC.md](/Users/sl/code/flame/SPEC.md) - Compaction format specification
- [Phase 1.2 IMPLEMENTATION.md](../1.2-context-assembly/IMPLEMENTATION.md) - Context generation

## Open Questions

1. **Summary Message Access**: How to reliably read the summary message after compaction? Options:
   - Read session messages via SDK
   - Store in plugin state during compaction hook
   - Request new hook for post-compaction access

2. **Compaction Timing**: The `session.compacted` event may fire before or after our hook completes. Need to verify timing.

3. **Summary Format**: Should the summary be structured (JSON) or freeform text? Structured is more machine-parseable, freeform is more natural.
